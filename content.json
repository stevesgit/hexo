{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/11/06/hello-world/"},{"title":"Balanced_Binary_Tree","text":"判断是否是平衡二叉树 QuestionEditorial Solution My SubmissionsTotal Accepted: 147366Total Submissions: 408360Difficulty: EasyContributors: AdminGiven a binary tree, determine if it is height-balanced.For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.Subscribe to see which companies asked this question 平衡二叉树：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。如何解决这道题目一个思路就是按照递归的思路去做。先去判读根节点的左右两边的深度差是否大于1，小于的话再去判断他的子树是否为平衡二叉树。这里就要借助递归。 1234567891011121314151617class Solution { public: bool isBalanced(TreeNode* root) { if(root == NULL) return true; if(root-&gt;left == NULL&amp;&amp;root-&gt;right == NULL) return true; if(abs(depth(root-&gt;left)-depth(root-&gt;right))&gt;1) return false; return isBalanced(root-&gt;left)&amp;&amp;isBalanced(root-&gt;right); } int depth(TreeNode* root){ if(root == NULL) return 0; return max(1+depth(root-&gt;left),1+depth(root-&gt;right)); } }; 一开始我觉得这种算法很顺手的，思考的时候也很简单。但是我后来在leetcode上测了下时间有快20ms，就觉得有问题，原来一看这里又两层递归就是递归里面套递归，所以花费时间很长时间在这里面。这种算法的时间复杂度为nlogn所以大量时间花费在了算书的深度上。然后上网查了下有如下的算法： 1234567891011121314151617181920212223class Solution {public: bool isBalanced(TreeNode* root) { // write code here int high=0; return isBalance1(root,high); } bool isBalance1(TreeNode* root,int &amp;high) { if(root==NULL) { high=0; return true; } int lhigh,rhigh; if(!isBalance1(root-&gt;left,lhigh)||!isBalance1(root-&gt;right,rhigh)) return false; if(lhigh-rhigh&gt;1||lhigh-rhigh&lt;-1) return false; high=(lhigh&gt;=rhigh?lhigh:rhigh)+1; return true; }}; 这种算法就用了一层递归，高度的递归在算平衡里面已经解决了，所以速度要比上面的要快。","link":"/2016/12/25/Balanced-Binary-Tree/"},{"title":"指针实现二维数组","text":"早上解决了昨天的那个队列的问题，结果发现错误的原因是出队列的那个函数存在着问题，具体的原因是那个队列的头是不应该存任何数据的，如果队列要换头的话就应该是front-&gt;next作为换头的语句Q-&gt;front-&gt;next=p-&gt;next 而不是之前的Q-&gt;front = p-&gt;next。中间调试了很久一直调试不出来，C出现的问题的时候，虽然可以调试，但是调试的时候很难看出问题，需要一步步仔细的检查。然后就是研究了下指针数组，数组指针，用指针实现数组。也就是昨天的那一块用数组的方式实现层序遍历。具体代码如下。// 分配内存 struct TreeNode* ** traversalNode = (struct TreeNode* **)malloc(*returnSize * sizeof(struct TreeNode* *)); int **traversalVal = (int**)malloc(*returnSize * sizeof(int*)); *columnSizes = (int*)malloc(*returnSize * sizeof(int)); 指针一开始不容易理解，但只要理解了，其实这三种格式都是一样的，就是在分配内存，先说最简单的就是最下面的那一行代码，这就是一个一唯数组，首先就是开一块能存储8个int的大小的空间，然后把指向该空间的首地址传递给 *columnSizes,然后我们访问数组的每一个元素就*columnSizes[0]~*columnSizes[7]访问。平常我们说数组就是指针，int a[5];*a, *(a+1);可以这样转化。当然我觉得*(*columnSizes+1)也可实现。 再来说上面的那几行，其实也是一样的，无非这里开辟内存的空间变成了int,然后这里面存了比如说有`8 * sizeof(int),同理是开辟了一块存储8int大小的地址这可以时说是我们二维数组中的第一维度的存储空间。然后把这个存储空间的首地址赋值给了int *traversalVal。但是这里要考虑到一个问题，我们为什么要这样做，和int a[9][10]有什么区别吗?好了问题来了，当我们这样做有什么不同吗？答案是有，目前我能想到的就是，这样做能够更好的利用空间。怎么说呢，他能保证数组的每块空间都能利用到。（因为我们在操作的时候只知道一个树的深度，但不知道树每层有多少个节点），也就是说我们只能确定a[n]数组的第一个维度。当我们需要确定数组的第二个维度的时候，只需要traversalVal[0] = (int)malloc(n * sizeof(int));这句话的意思就是说把存了这么多n*int存储空间的首地址指向给traversalVal[0];现在这块内容就变成了n个int的首地址了（就是说traversalVal[0]是这块内容的指针，指向这块内容的地址）。然后也就是说traversalVal[n]`指向的内容（内容只要是Int就行，多大的int不做限制）的地址。","link":"/2016/12/05/C-12-5/"},{"title":"Delete_node_in_bst","text":"Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.Basically, the deletion can be divided into two stages:Search for a node to remove.If the node is found, delete the node.Note: Time complexity should be O(height of tree). root = [5,3,6,2,4,null,7] key = 3 5 / \\ 3 6 / \\ \\ 2 4 7 Given key to delete is 3. So we find the node with value 3 and delete it. One valid answer is [5,4,6,2,null,null,7], shown in the following BST. 5 / \\ 4 6 / \\ 2 7 Another valid answer is [5,2,6,null,4,null,7]. 5 / \\ 2 6 \\ \\ 4 7解析这道题目重点分以下几种情况去分析 如果要删除的那个节点存在，且他的左右子树不都存在。那就直接用子树去替代被删除的节点。 如果要删除的节点左右子树都存在的话，正如上面所示的其实有两种解决方案，一种就是拿右子树的最小值去替代，另外一种就是拿左子树的最大值去替代。替代完之后又要删除替代的那个节点（这里逻辑就可以套用1去解决）。12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: TreeNode* deleteNode(TreeNode* root, int key) { if(!root) return NULL; //搜索那个要删除的节点 if(key &lt; root-&gt;val){ //在左子树搜 root-&gt;left = deleteNode(root-&gt;left,key); } else if(key &gt; root-&gt;val){ //在右子树搜 root-&gt;right = deleteNode(root-&gt;right,key); } else { //找到删除节点，而且左右子树只存在一个以下。 if(!root-&gt;left||!root-&gt;right){ root = (root-&gt;left) ? root-&gt;left : root-&gt;right; }else{ //左右子树都存在 TreeNode* cur; cur = root-&gt;right; while(cur-&gt;left){ cur = cur-&gt;left ; } root-&gt;val = cur-&gt;val; //删除右子树下用来替换的节点。 root-&gt;right = deleteNode(root-&gt;right,cur-&gt;val); } } return root; }};","link":"/2017/02/06/Delete-node-in-bst/"},{"title":"lca_of_bst","text":"Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).” _______6______ / \\ ___2__ ___8__ / \\ / \\ 0 _4 7 9 / \\ 3 5For example, the lowest common ancestor (LCA) of nodes 2 and 8 is 6. Another example is LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition. 意思就是找俩个节点的共同祖先。这是一颗二叉搜索树，解决思路就比较简答。输入参数是根节点和找共同祖先的两个节点。我们就可以让两个节点和root节点做比较。有以下几种情况： 两个节点中一个比根节点大，另一个比根节点小。那么他们的祖先就是root。 两个节点有一个节点等于根节点，那么很显然他们的祖先就是root。 两个节点都比root节点大，那么缩小两个几点的搜索范围，到root的右子树中，然后再和root-&gt;right 做比较。 同理，两个节点都比root的节点小，到root的左子树做比较。 代码如下： 123456789101112131415161718192021222324/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { if((root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val&lt; q-&gt;val) ||(root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val&gt; q-&gt;val)) return root; if(root-&gt;val == p-&gt;val ||root-&gt;val== q-&gt;val) return root; if(root-&gt;val&gt;p-&gt;val&amp;&amp;root-&gt;val&gt;q-&gt;val) return lowestCommonAncestor(root-&gt;left,p,q); if(root-&gt;val&lt;p-&gt;val&amp;&amp;root-&gt;val&lt;q-&gt;val) return lowestCommonAncestor(root-&gt;right,p,q); }};","link":"/2017/01/18/LCA-Of-BST/"},{"title":"二叉树的一些特点","text":"性质 第i层的节点数为 2^(i-1); 深度为k的节点数为2^k-1 (k&gt;=1); n0=n2+1 n0为度为0的节点就是叶节点，n2为度为2的节点 n个节点数，则深度为(log2n)+1 ①如果i&gt;1,双亲节点就是i/2;②2i&gt;n结点i无左儿子，否则左孩子节点是2i;③2i+1&gt;n则节点没有右孩子，否则右孩子为2i+1; 二叉树的遍历二叉树有前序遍历，中序遍历和后续遍历。如上图所示的一棵二叉树，对应的遍历结果分别是： 前序（NLR）：A B D C E G H F I 中序（LNR）：D B A G E H C F I 后序（LRN）：D B G H E I F C A 层序：A B C D E F G H I 按照程序的思想去理解这三种遍历前序遍历 1234567void preOrderTraverse(Bitree T){ if(T == NULL) return; printf(&quot;%d&quot;,T-&gt;val); preOrderTraverse(T-&gt;lchild);//先序遍历左子树 preOrderTraverse(T-&gt;rchild);//先序遍历右子树} 中序遍历 1234567void preOrderTraverse(Bitree T){ if(T == NULL) return; preOrderTraverse(T-&gt;lchild);//中序遍历左子树 printf(&quot;%d&quot;,T-&gt;val); preOrderTraverse(T-&gt;rchild);//中序遍历右子树} 后序遍历 1234567void preOrderTraverse(Bitree T){ if(T == NULL) return; printf(&quot;%d&quot;,T-&gt;val); preOrderTraverse(T-&gt;lchild);//后序遍历左子树 preOrderTraverse(T-&gt;rchild);//后序遍历右子树} 推导遍历结果 已知前序遍历为ABCDEF 中序遍历为CBAEDF 求后序遍历结果 因为先序遍历可以知道根节点，中序遍历可以知道左右树。所以A为根，CB为左子树，EDF为右子树。CB当中B为根,B为A的左儿子，C为B的儿子，因为在中序遍历中C先打印做C为B的左儿子。DEF中D为根，E为D的左儿子，F为右儿子。图1图2图3 已知中序是ABCDEFG,后续是BDCAFGE,求先序遍历的结果。 根节点可以通过后续得知，中序知道左右子树，所以可以求出先序。结果为EACBDGF注意：前序遍历和后续遍历结果知道不能求出中序，因为两者都是只能得出根节点，左右子树不能确定。","link":"/2017/01/08/binary-tree/"},{"title":"Sum_to_leaf_numbers","text":"Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number.An example is the root-to-leaf path 1-&gt;2-&gt;3 which represents the number 123.Find the total sum of all root-to-leaf numbers.For example, 1 / \\ 2 3The root-to-leaf path 1-&gt;2 represents the number 12.The root-to-leaf path 1-&gt;3 represents the number 13.Return the sum = 12 + 13 = 25. 解析这道题目不难，用递归很好解决，只要有儿子就要加数字，这里的数字组成方式是旧的树*10+新的数。 12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: int sumNumbers(TreeNode* root) { if(!root) return 0; int sum=0; getSum(root,root-&gt;val,sum); return sum; } void getSum(TreeNode * root,int number,int &amp;sum){ if(root-&gt;left) getSum(root-&gt;left,number*10+root-&gt;left-&gt;val,sum); if(root-&gt;right) getSum(root-&gt;right,number*10+root-&gt;right-&gt;val,sum); if(!root-&gt;left&amp;&amp;!root-&gt;right){ sum += number; } }};","link":"/2017/02/06/Sum-to-leaf-numbers/"},{"title":"invert_tree","text":"Invert a binary tree. 4 / \\ 2 7 / \\ / \\ 1 3 6 9to 4 / \\ 7 2 / \\ / \\ 9 6 3 1Trivia:This problem was inspired by this original tweet by Max Howell: Google: 90% of our engineers use the software you wrote (Homebrew),but you can’t invert a binary tree on a whiteboard so fuck off. 1234567891011121314151617181920212223Subscribe to see which companies asked this question/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: TreeNode* invertTree(TreeNode* root) { if(root == NULL) return NULL; root-&gt;left = invertTree(root-&gt;left); root-&gt;right = invertTree(root-&gt;right); TreeNode *tmp = root-&gt;left; root-&gt;left = root-&gt;right; root-&gt;right = tmp; return root; }}; 这到题目不难，主要用了递归的思想，反转二叉树就是每个节点下的左右儿子，我们需要从他的最下面开始反转，这里用递归就很合适。","link":"/2017/01/18/invert-tree/"},{"title":"max_depth_tree","text":"Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Subscribe to see which companies asked this question 1234567891011121314151617/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: int maxDepth(TreeNode* root) { if(root == NULL) return 0; return max(1+maxDepth(root-&gt;left),1+maxDepth(root-&gt;right)); }}; 这道题目就是不断的递归左右子树，父的深度比儿子深度大1，左右儿子深度做比较，得出最大深度。可以看出递归思想在解决树问题的重要性。","link":"/2017/01/18/max-depth-tree/"},{"title":"2017年计划","text":"2017年计划 学好JS。之前入WEB这个坑的时候，粗略地学过点js，只是学了点皮毛，感觉Web没有JS确实玩不起来。 研究下C。读些开源的项目，巩固C的知识，C是接触的第一门语言，搞过单片机，但是用的也是皮毛，希望能静下心来学一波C。 写一个MVC的框架。自己写一个框架和用别人的框架应该很不一样，设计模式，一些ORM的设计，所涉及的知识很多，很锻炼后端人员的基本功。 读《HTTP权威指南》和《高性能Mysql》。这两本书很厚，目前也只是读的自己所想知道的知识，接下来希望自己能继续深入学习。 积累一些数据结构和算法的知识，继续做一些leetcode上的题目。 有空的时间可以看下操作系统和计算机原理这些书，补充一下自己的不足。 以上是我2017年的计划，貌似计划有点过多，而且2017年的下半年自己也是正式工作了，时间上更是少之又少，列以上计划一方面是为了让自己有事情做，另外一方面是让自己知道有很多不足，能够鞭策自己学习，不要浪费仅剩下一学期的大学时间。","link":"/2017/02/25/plan-of-2017/"},{"title":"path_sum_III","text":"You are given a binary tree in which each node contains an integer value.Find the number of paths that sum to a given value.The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000. root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8 10 / \\ 5 -3 / \\ \\ 3 2 11 / \\ \\ 3 -2 1 Return 3. The paths that sum to 8 are: 1. 5 -&gt; 3 2. 5 -&gt; 2 -&gt; 1 3. -3 -&gt; 11题目就是求和为8的向下的路径数1，2，3，4，5是连续的五段路程不能跳过。如果想到站点5到达各地有几条路程，5-&gt;4-&gt;3-&gt;2-&gt;1 ，5-&gt;4-&gt;3-&gt;2，5-&gt;4-&gt;3，5-&gt;4，有四条路径。找和为8的路径只是多加了个条件。首先我们以root为节点，向下查找，再以root的左右儿子为节点查找，然后左右儿子又以自己的左右儿子为节点向下查找。所以用递归来完成。 123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: int pathSum(TreeNode* root, int sum) { int res = 0; if(root == NULL) return res; return dfs(root,sum)+pathSum(root-&gt;left,sum)+pathSum(root-&gt;right,sum); } int dfs(TreeNode* root,int sum){ int res = 0; if(root == NULL) return res; if(root-&gt;val == sum) res++; res+= dfs(root-&gt;left,sum-root-&gt;val); res+= dfs(root-&gt;right,sum-root-&gt;val); return res; }}; 这里的深度搜索dfs和下面求平衡二叉树时的depth是类似的。 1234567891011121314151617class Solution { public: bool isBalanced(TreeNode* root) { if(root == NULL) return true; if(root-&gt;left == NULL&amp;&amp;root-&gt;right == NULL) return true; if(abs(depth(root-&gt;left)-depth(root-&gt;right))&gt;1) return false; return isBalanced(root-&gt;left)&amp;&amp;isBalanced(root-&gt;right); } int depth(TreeNode* root){ if(root == NULL) return 0; return max(1+depth(root-&gt;left),1+depth(root-&gt;right)); } };","link":"/2017/01/08/path-sum-III/"},{"title":"SameTree","text":"Same Tree Given two binary trees, write a function to check if they are equal or not.Two binary trees are considered equal if they are structurally identical and the nodes have the same value.Subscribe to see which companies asked this question 题目就是判断两颗树是不是相同的树。解决思路：依次去判断这棵树的每个节点，是否存在这个节点，每个节点的值是否一样，然后他的子节点是否相同是否遵循以上规则。这就可以用递归来做。时间复杂度O(n),空间复杂度O(logn) 123456789101112131415161718192021/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: bool isSameTree(TreeNode* p, TreeNode* q) { if(p == NULL&amp;&amp;q == NULL) return true; if(p == NULL||q == NULL) return false; if(p-&gt;val != q-&gt;val) return false; return isSameTree(p-&gt;left,q-&gt;left)&amp;&amp;isSameTree(p-&gt;right,q-&gt;right); } };","link":"/2016/12/19/sameTree/"},{"title":"三种工厂模式","text":"阅读《设计模式之禅》后的总结。 前言之前的工厂模式有看过，但是没过多久就会忘，主要还是自己平常写代码业务逻辑的时候缺少思考，可能也就会用个单例模式。然后网上很多有关设计模式的介绍，感觉有些还是介绍的不够具体，或者说只介绍到了工厂模式的一部分吧。 工厂方法模式 工厂方法模式的定义：Define an interface for ceating an object ,but let subclasses decide which class to instantiate.Factory Method lets a class defer instantiation to subclasses(定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到器子类。) 12345678 /** * 产品类接口 */interface Product{ public function method1(); public function method2(); } 123456789101112 /** * 具体产品类 */public class ConcreteProduct1 implements Product{ public function method1(){ //业务逻辑 } public function method2(){ //业务逻辑 }; } 123456 /** * 工厂类 */ interface Creator{ public creatorProduct();} 1234567891011121314 /** * 具体工厂类 */public class ConcreteCreator implements Creator{ public function creatorProduct($product){ try{ $productObj = new $product; }catch(Exception $e){ //异常处理 } return $productObj; }} 12345678public class Client{ public function main(){ //用工厂类制造product1 $fc = new ConcreteCreator(); $cp1 = $fc-&gt;creatorProduct(\"ConcreteProduct1\"); $cp1-&gt;method1(); }} 简单工厂模式 简单工厂模式又称静态工厂模式 就是把上面的方法ConcreteCreator()改为静态就可以了。优点很明显，就是不用实例化工厂类直接调用工厂方法就可以了。 抽象工厂模式 优点 封装性 产品族内的约束为非公开状态 缺点 产品族的扩展非常困难 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166&lt;?php/** * 抽象工厂模式 2010-05-28 sz * @author phppan.p#gmail.com * http://www.phppan.com 哥学社成员（http://www.blog-brother.com/） * @package design pattern */ /** * 抽象工厂 */interface AbstractFactory { /** * 创建等级结构为A的产品的工厂方法 */ public function createProductA(); /** * 创建等级结构为B的产品的工厂方法 */ public function createProductB(); } /** * 具体工厂1 */class ConcreteFactory1 implements AbstractFactory{ public function createProductA() { return new ProductA1(); } public function createProductB() { return new ProductB1(); }} /** * 具体工厂2 */class ConcreteFactory2 implements AbstractFactory{ public function createProductA() { return new ProductA2(); } public function createProductB() { return new ProductB2(); }} /** * 抽象产品A */interface AbstractProductA { /** * 取得产品名 */ public function getName();} /** * 抽象产品B */interface AbstractProductB { /** * 取得产品名 */ public function getName();} /** * 具体产品Ａ1 */class ProductA1 implements AbstractProductA { private $_name; public function __construct() { $this-&gt;_name = 'product A1'; } public function getName() { return $this-&gt;_name; }} /** * 具体产品Ａ2 */class ProductA2 implements AbstractProductA { private $_name; public function __construct() { $this-&gt;_name = 'product A2'; } public function getName() { return $this-&gt;_name; }} /** * 具体产品B1 */class ProductB1 implements AbstractProductB { private $_name; public function __construct() { $this-&gt;_name = 'product B1'; } public function getName() { return $this-&gt;_name; }} /** * 具体产品B2 */class ProductB2 implements AbstractProductB { private $_name; public function __construct() { $this-&gt;_name = 'product B2'; } public function getName() { return $this-&gt;_name; }} /** * 客户端 */class Client { /** * Main program. */ public static function main() { self::run(new ConcreteFactory1()); self::run(new ConcreteFactory2()); } /** * 调用工厂实例生成产品，输出产品名 * @param $factory AbstractFactory 工厂实例 */ public static function run(AbstractFactory $factory) { $productA = $factory-&gt;createProductA(); $productB = $factory-&gt;createProductB(); echo $productA-&gt;getName(), '&lt;br /&gt;'; echo $productB-&gt;getName(), '&lt;br /&gt;'; } } Client::main();?&gt;","link":"/2017/02/17/%E4%B8%89%E7%A7%8D%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"title":"二叉树的前中后非递归实现","text":"今天做了一道题目，实现二叉搜索树的迭代，实际上就是一个实现二叉树的中序遍历。之前有做过二叉树的中序遍历但是依然想不起细节，三种遍历当中后续遍历最麻烦，光理解没用，二叉树的遍历很常见，所以他的遍历一定要记住。 1234567891011121314151617//前序遍历void pre_order(TreeNode * root){ if(root==NULL) return; stack&lt;TreeNode*&gt; stk; stk.push(root); while(!stk.empty()){ TreeNode* cur = stk.top(); stk.pop(); visit(cur); if(cur-&gt;right) stk.push(cur-&gt;right); if(cur-&gt;left) stk.push(cur-&gt;left); } } 1234567891011121314151617181920212223242526//中序遍历//思路就是存在左儿子就压栈，不存在了就出栈，然后再把他的右儿子入栈再次压入右儿子的左儿子，压完了再出栈重复上面的。void in_order(TreeNode * root){ if(!root) return; stack&lt;TreeNode*&gt; stk; TreeNode *rootfirst = root; while(!stk.empty()||rootfirst == root){//第一次为了让空stk能进入循环。 //有左儿子就入栈。包括右儿子的左儿子 while(root){ stk.push(root); root = root-&gt;left; } if(!stk.empty){ TreeNode cur = stk.top(); visit(cur); stk.pop(); if(cur-&gt;right){ stk.push(cur-&gt;right); root = cur-&gt;right-&gt;left; } } }} 原地址 12345678910111213141516171819202122232425262728293031//后续遍历 class Solution { //第一种，基于前序遍历进行修改 public: vector&lt;int&gt; postorderTraversal(TreeNode *root) { vector&lt;int&gt; res; stack&lt;TreeNode*&gt; node_stack; if(root==NULL) return res; node_stack.push(root); TreeNode* cur=root; TreeNode* pre=NULL; while(!node_stack.empty()){ cur=node_stack.top(); if((cur-&gt;left==NULL&amp;&amp;cur-&gt;right==NULL)||((pre!=NULL)&amp;&amp;(pre==cur-&gt;left || pre==cur-&gt;right))) { //为什么基于前序遍历改后序遍历，这里是 (pre==cur-&gt;left || pre==cur-&gt;right) 这两个条件？ //因为栈的构建顺序依次是cur, cur-&gt;right, cur-&gt;left,所以pre可能是左子树或右子树。 //如果基于中序遍历改后序遍历，则条件变为了(cur-&gt;right == pre)，因为中序遍历的栈的构建顺序是cur的左儿子，左左儿子，左左左儿子,cur-&gt;right。这个顺序说明pre只能是cur的右子树。 res.push_back(cur-&gt;val); node_stack.pop(); pre=cur; }else{ if(cur-&gt;right!=NULL) node_stack.push(cur-&gt;right); if(cur-&gt;left!=NULL) node_stack.push(cur-&gt;left); } } return res; } };","link":"/2017/01/23/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E4%B8%AD%E5%90%8E%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0/"},{"title":"依赖注入和IOC","text":"依赖注入 依赖注入 (Dependency Injection，简称DI）Class A中用到了Class B的对象b，一般情况下，需要在A的代码中显式的new一个B的对象。采用依赖注入技术之后，A的代码只需要定义一个私有的B对象，不需要直接new来获得这个对象，而是通过相关的容器控制程序来将B对象在外部new出来并注入到A类里的引用中。 而我们通常注入依赖的方式有两种： 通过构造函数传入依赖，实现特定参数的构造函数，在新建对象时传入所依赖类型的对象。 通过setter方法注入依赖，实现特定属性的public set方法，来让外部容器调用传入所依赖类型的对象。 控制反转 控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（DependencyInjection，简称DI），还有一种方式叫“依赖查找”（DependencyLookup）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。 控制反转是一种思想，而依赖注入是这种思想的一种实现。 下面是一段IOC容器的实现代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171&lt;?php class Bim { public function doSomething() { echo __METHOD__, '|'; } } class Bar { private $bim; public function __construct(Bim $bim) { $this-&gt;bim = $bim; } public function doSomething() { $this-&gt;bim-&gt;doSomething(); echo __METHOD__, '|'; } } class Foo { private $bar; public function __construct(Bar $bar) { $this-&gt;bar = $bar; } public function doSomething() { $this-&gt;bar-&gt;doSomething(); echo __METHOD__; } } class Container { private $s = array(); public function __set($k, $c) { $this-&gt;s[$k] = $c; } public function __get($k) { // return $this-&gt;s[$k]($this); return $this-&gt;build($this-&gt;s[$k]); } /** * 自动绑定（Autowiring）自动解析（Automatic Resolution） * * @param string $className * @return object * @throws Exception */ public function build($className) { // 如果是匿名函数（Anonymous functions），也叫闭包函数（closures） if ($className instanceof Closure) { // 执行闭包函数，并将结果 return $className($this); } /** @var ReflectionClass $reflector */ $reflector = new ReflectionClass($className); // 检查类是否可实例化, 排除抽象类abstract和对象接口interface if (!$reflector-&gt;isInstantiable()) { throw new Exception(\"Can't instantiate this.\"); } /** @var ReflectionMethod $constructor 获取类的构造函数 */ $constructor = $reflector-&gt;getConstructor(); // 若无构造函数，直接实例化并返回 if (is_null($constructor)) { return new $className; } // 取构造函数参数,通过 ReflectionParameter 数组返回参数列表 $parameters = $constructor-&gt;getParameters(); // 递归解析构造函数的参数 $dependencies = $this-&gt;getDependencies($parameters); // 创建一个类的新实例，给出的参数将传递到类的构造函数。 return $reflector-&gt;newInstanceArgs($dependencies); } /** * @param array $parameters * @return array * @throws Exception */ public function getDependencies($parameters) { $dependencies = []; /** @var ReflectionParameter $parameter */ foreach ($parameters as $parameter) { /** @var ReflectionClass $dependency */ $dependency = $parameter-&gt;getClass(); if (is_null($dependency)) { // 是变量,有默认值则设置默认值 $dependencies[] = $this-&gt;resolveNonClass($parameter); } else { // 是一个类，递归解析 $dependencies[] = $this-&gt;build($dependency-&gt;name); } } return $dependencies; } /** * @param ReflectionParameter $parameter * @return mixed * @throws Exception */ public function resolveNonClass($parameter) { // 有默认值则返回默认值 if ($parameter-&gt;isDefaultValueAvailable()) { return $parameter-&gt;getDefaultValue(); } throw new Exception('I have no idea what to do here.'); } } // ---- $c = new Container(); $c-&gt;bar = 'Bar'; $c-&gt;foo = function ($c) { return new Foo($c-&gt;bar); }; // 从容器中取得Foo $foo = $c-&gt;foo; $foo-&gt;doSomething(); // Bim::doSomething|Bar::doSomething|Foo::doSomething // ---- $di = new Container(); $di-&gt;foo = 'Foo'; /** @var Foo $foo */ $foo = $di-&gt;foo; var_dump($foo); /* Foo#10 (1) { private $bar =&gt; class Bar#14 (1) { private $bim =&gt; class Bim#16 (0) { } } } */ $foo-&gt;doSomething(); // Bim::doSomething|Bar::doSomething|Foo::doSomething?&gt;","link":"/2017/02/23/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%92%8CIOC/"},{"title":"CGI,FastCGI,PHP-CGI,PHP-FPM重识","text":"CGI,FastCGI,PHP-CGI,PHP-FPM 之前研究了下一次完整的Web请求涉及到的过程，今天在学Java的JSP的时候就突然想起来想好好总结一下PHP的CGI有关的知识，之前看过好几遍CGI但是过一段时间总是忘记，又由于重新学习了一遍Web协议，这次再看也许会焕然一新。 CGI出现原因浏览器通过http协议向服务器请求一个资源时，如果这个请求是静态（图片，html，mp3,pdf…）,我们的HTTPServer(Nginx,Apache)能直接根据地址通过HTTP相应（Response）请求。但是我们访问的资源不可能只是静态的，如果是想访问动态的资源时怎么处理呢？Nginx服务器本身是处理不了的，他只能交给（应用服务器）Application Server来处理。但有一个问题Nginx服务器怎么和应用服务器通信呢，大家互相都不认识。为了解决这个问题，CGI就出现了。 CGI 通用网关接口（Common Gateway Interface/CGI）是一种重要的互联网技术，可以让一个客户端，从网页浏览器向执行在网络服务器上的程序请求数据。CGI描述了服务器和请求处理程序之间传输数据的一种标准。 上面是Wiki上关于CGI的解释，也就是说他是一种协议。我们看下CGI的特点，接着上面的当HTTP Service(nginx，Apache)接收到请求处理index.php的时候，他把这个请求交给了实现了CGI协议的CGI解释器进程，接下来解释器进程会解析php.ini文件，初始化执行环境，然后处理请求，再以规定CGI规定的格式返回处理后的结果，退出进程。下一个请求来时再创建新进程。这里存在一个问题就是当我执行完index.php后我想访问next.php时会重复前面的解析php.ini文件，初始化执行环境而且每次请求的时候他会启动一个进程，当多个请求同时来的时候会同时启动多个进程会给服务器带来压力。综上CGI解释器进程的缺点是做一些重复工作，进程进来执行完后退出，利用率低。为了解决这几个问题出现了新的协议CGI的升级版Fast-CGI Fast-CGIFastCGI像是一个常驻(long-live)型的CGI，它可以一直执行着，只要激活后，不会每次都要花费时间去fork一次(这是CGI最为人诟病的fork-and-execute 模式)。它还支持分布式的运算, 即 FastCGI 程序可以在网站服务器以外的主机上执行并且接受来自其它网站服务器来的请求。 FastCGI是语言无关的、可伸缩架构的CGI开放扩展，其主要行为是将CGI解释器进程保持在内存中并因此获得较高的性能。众所周知，CGI解释器的反复加载是CGI性能低下的主要原因，如果CGI解释器保持在内存中并接受FastCGI进程管理器调度，则可以提供良好的性能、伸缩性、Fail- Over特性等等。 PHP-CGI一开始一看名字我以为PHP-CGI是一个实现CGI协议的CGI进程，但其实不是，他是实现了FastCGI协议的进程。PHP-CGI是PHP内置的，PHP本身应该是没有实现CGI协议的进程（因为这个太落后了）。 PHP-CGI与PHP-FPM一样，也是一个fastcgi进程管理器，PHP-CGI的问题在于 1、PHP-CGI变更php.ini配置后需重启PHP-CGI才能让新的php-ini生效，不可以平滑重启 2、直接杀死php-cgi进程,php就不能运行了。(PHP-FPM和Spawn-FCGI就没有这个问题,守护进程会平滑从新生成新的子进程。） 针对PHP-CGI的不足，PHP-FPM应运而生。 PHP-FPMPHP-FPM是一个PHP FastCGI管理器，是只用于PHP的，使用PHP-FPM来控制PHP-CGI的FastCGI进程，它负责管理一个进程池，来处理来自Web服务器的请求。可以在 http://php-fpm.org/download 下载得到。 特点：PHP-FPM的使用非常方便，配置都是在PHP-FPM.ini的文件内，而启动、重启都可以从php/sbin/PHP-FPM中进行。更方便的是修改php.ini后可以直接使用PHP-FPM reload进行加载，无需杀掉进程就可以完成php.ini的修改加载。使用PHP-FPM可以使PHP有不小的性能提升。PHP-FPM控制的进程CPU回收的速度比较慢，内存分配的很均匀。 参考 WEB请求处理三涉及到CGI部分 segmentfault尹川的回答","link":"/2016/12/21/%E5%85%B3%E4%BA%8ECGI/"},{"title":"单例模式","text":"单模式的定义：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。 优点 由于单励模式在内存中只有一个实例，减少了内存的开支，特别是一个对象需要频繁地创建和销毁，而且创建或销毁时性能又无法优化，单例模式的优势就非常明显。 由于单例模式只生成一个实例，所以减少了系统的性能开销，当一个对象的产生需要比较多的资源时，如读取配置，产生其他依赖对象时，则可以通过在应用启动时产生一个单对象。 使用场景 创建一个对象需要消耗很多资源的，如要访问IO和数据库等资源。 在整个项目中需要一个共享的访问点或共享数据，例如一个Web页面上的计数器，可以不用每次刷新都记录到数据库中，使用单例模式保持计数器的值。 单模式的如下面代码所示。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?php/** * 懒汉式单例类 */class Singleton { /** * 静态成品变量 保存全局实例 */ private static $_instance = NULL; /** * 私有化默认构造方法，保证外界无法直接实例化 */ private function __construct() { } /** * 静态工厂方法，返还此类的唯一实例 */ public static function getInstance() { if (is_null(self::$_instance)) { self::$_instance = new Singleton(); } return self::$_instance; } /** * 防止用户克隆实例 */ public function __clone(){ die('Clone is not allowed.' . E_USER_ERROR); } /** * 测试用方法 */ public function test() { echo 'Singleton Test!'; } } /** * 客户端 */class Client { /** * Main program. */ public static function main() { $instance = Singleton::getInstance(); $instance-&gt;test(); }} Client::main();?&gt;","link":"/2017/02/16/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"title":"写给自己的2017","text":"今天是2018年了，写点年终总结，对自己的2017回顾。想写之前觉得自己思如泉涌，觉得自己的2017有太多的可以说活了，但是写的时候才发现很多东西想写却写不出。 2017年给自己的计划其实说不上很难，因为是毕业的一年，所以2017年年初，我内心还是有小目标的，一个就是找一份自己满意工作，然后交个女朋友。这两点差不多都做到了。 还记的年初的时候，自己还在为以后的事情担心，其实大学里对以后想要做什么，没有很具体的想法，就觉得做个程序员很酷的。从15年开始决定要走程序员这条路以来也已经两年多了。为了能让自己坚持下去，买了各种书籍，买了macbook，因为我知道没当我想放弃的时候看着这些家当一定会不舍得的。 17年来对我来说可能是很特别的一年，第一次踏出校园，走进了社会，什么事情都要开始独当一面。 17年要说什么特别的收获，我觉得自己的学习能力比以前要强了，在初创型公司，什么东西都没有，让我有机会参与进去，养成了单独解决问题的能力。还有自己已经慢慢培养起来了阅读，从小对阅读没有特别的兴趣，都是带着任务去看书。可每当发现身边的人对一些事物侃侃而谈的时候，我真觉得自己的知识面，太窄了，看的书也是一些技术书籍，所以在年底的时候我做了一个阅读计划。我以前是很痛恶语文的那种人，我反感那些语文阅读题目的标准答案，完全觉得是乱揣摩他人的想法。尤然记得高一语文老师对我们说，他的一个学生以前也很不屑看书，但他到了大学竟然开始读起了四大名著。可是我呢？现在想起来大学里大一大二跑图书馆除了去准备期末考试，还真没读过什么书。到了大四醒悟过来了也只是学习编程罢了。回顾了下自己大学里看的书一只手数的过来。现在想想好可惜，大学是最自由的时光，我如果抽两年看一些书，我的知识面和思想一定和现在不是一个级别。 现在我越来越觉得，如果是一个技术人员，不要把自己给固化了，觉得任何和人文有关的东西都没什么用。死专在一个领域要么成了专家，要么就成了书呆子。其实我这个人好奇心是特别重的人，我决定走技术这条路也是因为我对技术充满好奇。当我遇到我不懂的行业和事情，我总有想一探究竟。所以当初觉定编程方向时还是坚定的选了后端，因为后端对我来说比前端更神秘一些。17年最后两个月，我接触了一些新的领域，我开始看一些经济书，开始关注区块链。 17年说不上有什么遗憾的，要说遗憾的觉得自己的大学的前三年是充满遗憾的，没有去谈恋爱，草草过完了自己的大学生涯。若干年后，别人回忆自己的大学有什么什么？我真不知道有什么值得拿出来说的。 18年来了，小时候看选秀我型我秀，总听他们唱《年轻的战场》，除了旋律听不出什么特别的。走出校园开始，我已经站在了一个新的战场，此处的BGM必须是《年轻的战场》，之后也会给自己制定一个上半年的计划。","link":"/2018/01/01/%E5%86%99%E7%BB%99%E8%87%AA%E5%B7%B1%E7%9A%842017-1/"},{"title":"后期静态绑定解读","text":"后期静态绑定解读先看下官网的这段代码[官方解释][1]下面摘自官网 后期静态绑定的解析会一直到取得一个完全解析了的静态调用为止。另一方面，如果静态调用使用 parent:: 或者 self:: 将转发调用信息。准确说，后期静态绑定工作原理是存储了在上一个“非转发调用”（non-forwarding call）的类名。当进行静态方法调用时，该类名即为明确指定的那个（通常在 :: 运算符左侧部分）；当进行非静态方法调用时，即为该对象所属的类。所谓的“转发调用”（forwarding call）指的是通过以下几种方式进行的静态调用：self::，parent::，static:: 以及 forward_static_call()。可用 get_called_class() 函数来得到被调用的方法所在的类名，static:: 则指出了其范围。 12345678910111213141516171819202122232425262728293031&lt;?phpclass A { public static function foo() { static::who(); } public static function who() { echo __CLASS__.&quot;\\n&quot;; }}class B extends A { public static function test() { A::foo(); parent::foo(); self::foo(); } public static function who() { echo __CLASS__.&quot;\\n&quot;; }}class C extends B { public static function who() { echo __CLASS__.&quot;\\n&quot;; }}C::test();//A C C?&gt; 这里C::test() 调用执行到B下的test()然后依次执行A::foo() parent::foo() self::foo()A::foo()直接看成是A自己执行自己的方法，所以他调用自己的static::who() 这边进来没用到转发调用 直接输出Aparent::foo() 进入A下的foo 里面是后期静态绑定的who ，这里执行的上一次非转发调用官网所说的上一个“非转发调用”（non-forwarding call）的类名。 后期静态绑定工作原理是存储了在上一个“非转发调用”（non-forwarding call）的类名很明显这里的static这的类名不是B下的因为B是转发调用，B的上一层就是C，C下有who方法因此就执行这里的who，打印C。同理，self也是，打印的也是C。 我们把上面的这段代码改一下 1234567891011121314151617181920212223242526272829303132&lt;?phpclass A { public static function foo() { static::who(); } public static function who() { echo __CLASS__.&quot;\\n&quot;; }}class B extends A { public static function test() { A::foo(); parent::foo(); self::foo(); } public static function who() { echo __CLASS__.&quot;\\n&quot;; }}class C extends B { public static function who() { echo __CLASS__.&quot;\\n&quot;; }}class D extends C { public static function who() { echo __CLASS__.&quot;\\n&quot;; }}D::test();//A D D 这时候结果不再是 A C C 而是 A D D ,也就是说这里的static 绑定到了D,而非C。同理 123456789101112131415161718192021222324252627&lt;?phpclass A { public static function foo() { static::who(); } public static function who() { echo __CLASS__.&quot;\\n&quot;; }}class B extends A { public static function test() { A::foo(); parent::foo(); self::foo(); } public static function who() { echo __CLASS__.&quot;\\n&quot;; }}class C extends B {}class D extends C {}D::test();//A B B 如果我们只留下A下的foo() 12345678910111213141516171819202122232425&lt;?phpclass A { public static function foo() { static::who(); } public static function who() { echo __CLASS__.&quot;\\n&quot;; }}class B extends A { public static function test() { A::foo(); parent::foo(); self::foo(); }}class C extends B {}class D extends C {}D::test();// A A A 也就这里没有静态绑定成功 直接用的就是A类下的who()现在就很明显了当我们调用一个static::function() (静态绑定方法)他会把这个方法绑定到在继承关系中存在这个方法的最年轻的类中的方法。 [1]: http://www.golaravel.com/php/language.oop5.late-static-bindings.html","link":"/2016/10/28/%E5%90%8E%E6%9C%9F%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A%E8%A7%A3%E8%AF%BB/"},{"title":"聊聊架构之如何写好代码（1）","text":"一开始看《聊聊架构》这本书有点懵的，因为觉得架构就是软件架构，里面提到一些生命周期，听上去学术，但实际上是很有道理的，架构是无处不在的，这里我会总接一些觉得还不错篇章，也作为一次读书笔记吧。 什么是代码先看一张图上面的方形可以理解为软件，结合我自己的编程经验，这就是一个典型的后端软件模型。这里可以把代码分为三部分：1.访问业务生命周期的代码2.业务逻辑代码。3.存储部分代码上图的服务就是访问业务生命周期的代码，业务逻辑就是业务。 那什么又是服务呢？书里的一个例子很形象：客户去银行办业务，接待客户的是银行柜员，而不是专业业务人员。柜员就是一个服务，以用户听的懂的方式去和用户沟通，并把用户的要求转化为业务语言，再由银行内部的专业业务人员执行相应操作，柜员最后把执行结果转化为用户的语言，为其服务。所以服务就是一个通道，是访问业务的一个通道。 但上面的图暴露了一个很严重问题，过于耦合，服务为完成用户访问生命周期，但上图却承担包括了组合业务和存储这两个还要提供用户访问。用户为完成访问业务逻辑生命周期，需要做的是： 服务首先要把业务的状态从存储中加载。这是一个生命周期，主体为业务状态获取。 服务调用并组合业务逻辑完成业务的访问。这是一个生命周期，主体为业务访问。 服务把业务逻辑执行后的状态保存到存储中。这是一个生命周期，主体为业务状态保存。 这里拿自己的后端代码打个比方，之前为了高效开发，公司的后端代码架构基本就是上面这种架构，也就是MC架构，这里的C端控制器做的工作很多，有业务逻辑，有粘合代码，甚至还包括了存储获取代码。每个业务没有重用性，不过幸好写的是基于restful架构的api，每个业务都是一个接口，业务代码基本上是独立的。但是业务代码没有重用性可言，所以上面这种模型是很不好的，我们应该弃用。 拆分后的架构拆分后的架构如图所示，可以看出各部分是独立的，黏合代码整合了业务和存储，服务则整合了黏合代码。在实际应用中，服务为控制器中的action，业务在独立的logic层，存储在model层。而黏合代码可以看做一个管理者即XXManager，比如一个订单业务黏合代码就是一个OrderManager类。 为什么要这样做有些人会问为什么不把存储挂在服务上，这样黏合代码就不需要了。但这样的后果就是让银行的核心人员，直接面接待客户，用户的访问因为沟通效率低就变得非常困难。黏合代码相当于一个具备行为和记忆的完整业务人，不应该直接面对用户。正确的方式应该是给用户独立的访问通道,就好比银行采用柜台人员来做接待一样。服务相当于柜台是面向用户的。用户的需求是变化最频繁的,服务的方式可以避免频繁的用户需求变化对内部分工的冲击。没有服务的保护会导致用户的需求直接冲击存储,西存储非常脆弱必须保护起来。还有人会问,为何不把存储挂在业务上?这也是可以的,大家把这叫作活动记录( Active record)但这会让关心业务模型的代码人员,受到存储的影响,必然无法专注于业务生命周期上。并且存储的变动,会极大地影响业务生命周期所以一般也不采用这种方式。毕竟内存持久化的问题是计算机体系结构本身的问题,不应该由业务代比码人员来解决。采用存储挂在黏合代码上的方式,可以让黏合代码成为一个完整的虚拟人虚拟人具备记忆和行为,可以均衡地处理上述两个问题。有以上两种方式的好处,而又没有太大的弊病,这才是最合适的。因此代码就划分出了以下几个责任 服务专注于用户(User)的需求,通过组织黏合代码,也就是虚拟人所提供的生命周期活动完成需求。 黏合代码专注于管理业务中对象的生命周期,并且通过存储保存或加载业务中对象的状态,实现对业务虚拟人的模拟。 业务专注于实现业务的生命周期活动。 存储专注于数据的保存和加载,并让数据和存储设备的存储粒度一一对应。 分工后各个业务都是独立的，不同部分的开发人员可以并行的进行开发，不仅提升力效率而且缩短了时间。比如负责业务逻辑的可以专注与业务逻辑的开发，存储部分独立了那么DBA做一些sql优话也不会影响到业务层。各个部分都是独立的，虽然前期会加大一些工作量，但是职能清晰后的代码是易维护的，能进行单元测试的。","link":"/2017/07/16/%E5%A6%82%E4%BD%95%E5%86%99%E5%A5%BD%E4%BB%A3%E7%A0%811/"},{"title":"新家","text":"由于阿里云太坑了，原本想一直用着阿里的那个学生服务器，可是后来阿里强行要求签到10天才能发抵用券，我索性就放弃治疗了。还好，腾讯还算厚道，我那个测试论坛现在还跑在腾讯的服务器上，每个月只是象征性地收一块钱，速度还比阿里的签到10天还要10快的服务器好多了。 从同事那听说 他有用github page 效果还蛮好，关键是我再也不用担心服务器续费问题了，这里以后就是记录我程序员生涯的地方了，蛮好。😊 这里主要还是写点PHP，C，数据结构，设计模式这类东西，希望对自己有点作用。","link":"/2016/10/04/%E6%96%B0%E5%AE%B6/"},{"title":"架构解密-撸书","text":"推荐指数：★★☆☆☆批评：这本书前面一通废话，感觉有点摘抄wiki，和你讲谁谁干嘛了，这种可以一笔带过的事情，全书却写了很多，不免有凑字数之嫌。还有说是解密架构，单独拿一章出来说却是一个很小的点。如网络基础，提到NIO，那你说一下NIO的特点架构这很是自然的，但作者就直接拿了一块ByteBuffer讲了一堆，整个章节结构可以说是东扯一点西扯一点。全书更像是作者的杂谈。 收获：作者懂得东西多，让我知道了架构中很多不熟悉的点，读起来自己感觉也有点累，很多东西都是涉略一下。罗列几个自己的疑惑点的关键词： traceroute 全双工 半双工 关于socket和tcp 缓冲区 滑动窗口 分布式算法 base准则 分布式事务(2pc 3pc) 共享内存 RPC框架工业级 zoreICe cpu内存 多核cpu cache line（64字节） mesi 分布式存储","link":"/2019/04/26/%E6%9E%B6%E6%9E%84%E8%A7%A3%E5%AF%86-%E6%92%B8%E4%B9%A6/"},{"title":"年终读书计划","text":"最近磨磨唧唧的不怎么想看书，就看了一本《刻意练习》，读完比较有感触，有可能的话会写一点读书笔记。 待看技术书籍： 《Java核心技术 I》要求涉及到J2E的知识都要过一遍 50% 《Spring MVC学习指南》阅读一遍 《重构》这本书买来 之后就一直冬眠着 《Spring实战》 最近已看的技术书籍： 《Servlet Jsp 和 Spring MVC初学指南》东西不多 拖延着断断续续看了很久 可以看的闲书： 《白夜行》以读完 11.12 《浪潮之巅上下》 《愿你的青春不负梦想》以为是自传 全是鸡汤 扔了 《解忧杂货铺》已读完 11.5 《三体》I读完 11.26 《一个叫欧维的人决定去死》 《刻意练习》已读完 《颠覆者-周鸿祎自传》以读完 12.03 《区块链技术驱动金融》","link":"/2017/10/24/%E5%B9%B4%E7%BB%88%E8%AF%BB%E4%B9%A6%E8%AE%A1%E5%88%92/"},{"title":"实习的那两个月","text":"两个月工作总结（9.22-11.30）前言 暑假一直在找实习，可是一直碰壁，第一网上找公司，没有经验，唯一去的两家都是培训机构，无奈在家学习了一个暑假。9月初， 暑假结束，我从家里出来找实习，那个时候学校里还是有很多课的（我们这专业就是这么变态），但是我觉得这些课都没什么用，就毅然决定出来找工作了。当时想的无非是，自己在家看书，都是些书本上的东西，实战的还是有缺乏。然后网上就找到了一家公司A，进去面试了，面试官是个干了10年的大牛，算是这家小公司的CTO，笔试的都是些比较基础的，涉及到一些前端的知识点。那场面试呢，面试官考我的也是很基础的东西，首先就是开发环境,我毫不犹豫的说我是MNMP环境，然后他接着问，是怎么安装这些环境的。我就说都很简单啊，就是用Brew安装的，还有Mysql可以下载一个安装包安装。他继续追问，那如果我要安装在一个指定的目录下，怎么办。当时我，一脸懵逼，用惯了Brew，一切都是固定的目录文件夹，确实没有考虑过指定的文件夹，安装，现在想来无非就是编译安装，with指定一下位置。然后他继续追问了一些HTTP的问题，TCP/IP和HTTP的关系，我当时还说错了这两者的依附关系，说TCP/IP属于HTTP，现在想来我暑假那段时间都做了点什么事情啊。再然后就说了点，关于PHP的正则的一些问题，贪婪匹配和严格匹配吧，也没解答好。这是我面的第一家公司，后来面进了，干了两天就不干不了，那个公司只有一个技术大牛，然后前后端一起做，也就是PHP也要干前端的活，还有就是技术氛围太差了。 离开了第一家实习的公司不久，我就获得了一家150团队的中小型公司B的面试机会，去面试前我还准备好好复习一下面试的基本知识。然后第二天一大早我就去面试了，那家公司一进去就是两大排，中间是过道，我看了下给人一种蛮好的技术氛围。进入面试环节，面试官上来看了下我的简历，还是老规矩，自我介绍一下。我感觉每次在自我介绍环节，都是很尴尬的状态，我说我本不是计算机专业，大学读的专业偏硬件，但是自学这个有一段时间了，对技术充满了兴趣。（真的好干）然后就是说一些项目经验什么的，我说项目经验目前还是没有，但是自己做过一个小论坛，博客之类的东西，然后部署在阿里云服务器上，在线上环境，可以给你看下，之后他就略微的看了下。（当时我对我的作品还是比较满意，但是现在想想那东西真不值得拿出手）。面试官接着问了技术的问题，问我关于mysql的Left Join特点和Join 的区别，我就回答了他。紧接着，问了我关于接口和抽象类的区别，我就开始处于模糊的状态，我说抽象类和接口是一个可以继承多个，一个不可以。然后他回答说，想让我说的不是这个点，是使用时候的区别。我答不上来，学艺不精啊。现在想想抽象类和接口确实区别还蛮大的，但当时学的时候没有充分的去分析和总结，这些确实做的不够。这些问题问的都是最最基础的，之后就问了点关于环境的问题，问我用什么编程软件，什么环境下编程什么的…面试结束，对自己感觉只能打70分，我给自己找了个借口是暑假一直在研究C和数据结构，php面向对象和一些myql确实没有深入的研究。但现在看来是不不成立的，这些真的是借口。但是终究，我还是进了这家公司，进去的时候一共有三个实习生，就我一个是本地的，其他都是江西的，一个已经干了一个月了，另外一个比我早来一天。 刚进来的时候，不知道做点什么，光搭环境就花了一天，公司用的环境是PHP7+Nginx+Mysql5.7+Centos6,就这点东西，我在Win下搭了大半个工作日，还是基于虚拟机的。后来也不知道咋弄的，坐在我旁边的同事HY就和我说，其实我们公司大多数环境都是用Docker的。额…然后又切换到Docker工作了一段时间。一开始，其实我的项目经理给我的时间是大概两个礼拜适应环境（这是我后来知道的，他们的态度是两个礼拜适应不了走人），其实我压根就不需要这么长时间，因为Laravel框架我早就会了，只需要几天时间回顾一下就可以了，但是我没有主动去接收任务，我研究了下公司的源码，甚至还想看Laravel的源码，研究一下，回头看，那段看源码的时间，确实是效率不高但有花时间的一段时期。索性时间不长，大概就是两个礼拜。然后就被安排任务了，第一个任务是跟着ZHL一起迁移API，其实迁移API怎么说呢，说简单也简单，想简单了就是复制粘贴的事，但我还是有去了解那些业务逻辑的。第一个貌似是一个detail详情的API，做的时候也是糊里糊涂的，讨教了ZHL很久，最终才解决了，有了第一个，下面就得心应手了，接连做了好几个也不费力。之后就是做了一个金融的后台接口，再之后就是举报API了。金融后台因为学校考试的原因，本来项目经理考虑要给其他人做的，我接了下来，以为我想学更多的东西嘛。最后还是赶着完成了这个项目，第一次做这个确实感觉经验很缺乏，很多东西都是中途加上去，边和前端调试变修改的。再就是我感觉做的最失败的东西了，举报的API，听需求的时候，当时因为后台接口和APP接口有点类似，总以为一些需求不是自己的需求，也觉得这个东西很简单，但是做着做着却发现，越做越复杂了，这是我没有想到的，再到了最后要上线的时候，又发现一个功能没有做，这点真的是需求写的不明确造成的。还有就是把一段本来可以写的很简答的代码，复杂化了，我竟然用了一个循环去做，也是醉了，也不知道当时自己这么想的。反正种种原因吧，反正挺失败的，上线也被我拖到了晚上11点，本来预期是9点左右就能上完的。","link":"/2016/12/03/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E4%B9%A0%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%9C%88/"},{"title":"网络之间的连接","text":"主要研究了一下一次完整的网络请求所经历的几个步骤对OSI模型的二三层，特别是在数据链路层传中的ARP进行了初步的认知。 大致可以看下这段文字 主机A的IP地址为192.168.1.1，MAC地址为0A-11-22-33-44-01；主机B的IP地址为192.168.1.2，MAC地址为0A-11-22-33-44-02；当主机A要与主机B通信时，地址解析协议可以将主机B的IP地址（192.168.1.2）解析成主机B的MAC地址，以下为工作流程：第1步：根据主机A上的路由表内容，IP确定用于访问主机B的转发IP地址是192.168.1.2。然后A主机在自己的本地ARP缓存中检查主机B的匹配MAC地址。第2步：如果主机A在ARP缓存中没有找到映射，它将询问192.168.1.2的硬件地址，从而将ARP请求帧广播到本地网络上的所有主机。源主机A的IP地址和MAC地址都包括在ARP请求中。本地网络上的每台主机都接收到ARP请求并且检查是否与自己的IP地址匹配。如果主机发现请求的IP地址与自己的IP地址不匹配，它将丢弃ARP请求。第3步：主机B确定ARP请求中的IP地址与自己的IP地址匹配，则将主机A的IP地址和MAC地址映射添加到本地ARP缓存中。第4步：主机B将包含其MAC地址的ARP回复消息直接发送回主机A。第5步：当主机A收到从主机B发来的ARP回复消息时，会用主机B的IP和MAC地址映射更新ARP缓存。本机缓存是有生存期的，生存期结束后，将再次重复上面的过程。主机B的MAC地址一旦确定，主机A就能向主机B发送IP通信了。 也就是说我们通信的时候不管怎么样都是需要获取Mac地址的，在同一个网络下可以直接使用ARP协议发送一个数据包。但是在不同的子网络下就是交给网关去处理。比如子网A下的a主机放送给子网B下的c数据时该怎么办呢？需要用到ARP协议吗。答案是肯定的。首先a找到网关的时候就要发送数据给网关，这里需要知道网关的ip地址和网关的mac地址，获取网关的mac地址就需要用到ARP协议，然后网关需要找到发送数据目的地建立连接，那么就又需要和子网B的网关建立连接发送数据，这里需要用到arp吗？那就看需要看第二层传递方式如果是以太网就需要用到ARP，如果是其他的传递方式可能就不需要（反正知道如果是），所以决定是否需要ARP，是由二层封装方式决定的。但是到了这里怎么和公网相连呢？如果是以太网就可能做一次广播，广播给他所在局域网内的网关。可能会通过多次路由转换到达目的地。A-R1-R2-R3-BA想要找到B，则只知道B的ip地址和自己的ip地址，对于A来说，B不在本地的链路上（B与A不属于同一个子网）则数据就交给路由器（网关）来处理。如果网关mac地址在本地ARP缓存中就直接连，如果没有就发起arp请求。到了R2收到数据包进行拆解，要找的IP地址是B，又不在自己的子网下，就交给R1的网关R2来处理，R2收到后重复前面的步骤交给网关R3，R3收到数据发现是在自己的子网下，就交给B来处理。但是这里的原地址和目标地址是不会变得。如果路由器实现NAT功能的话就是以下模式：就比如是这个样子的：A(10.1.1.2)—-|B(10.1.1.3) —|C(10.1.1.4)—| -GW(1.1.1.1)-Internet -Server 2.2.2.2 A 使用TCP Port 1025 访问 server TCP 80B 使用TCP Port 1025 访问 server TCP 80C 使用TCP Port 2000 访问 server TCP 443 Gateway 上的NAT table 如下：10.1.1.2 + TCP 1025 &lt;—-&gt; 1.1.1.1 + TCP 102510.1.1.3 + TCP 1025 &lt;—-&gt; 1.1.1.1 + TCP 102610.1.1.4 + TCP 2000 &lt;—-&gt; 1.1.1.1 + TCP 1027通过以上IP地址+ TCP端口号的映射，Gateway 可以唯一区分任何一个host。 注意这里A的数据到了网关（路由器）之后，网关（路由器）会对数据进行处理，把发送端的ip地址从A的ip地址改为网关的公网ip地址，再去发送数据包给其他的路由器。其他的路由器如果收到数据包，如果仍需要转发的话，依然需要把发送端的ip改为本公网的ip地址。那他们以自己的公网ip发送之后怎么如何区分数据是给谁的呢（毕竟每个公网下的子网都有很多ip地址）？那就是用到了上面的NAT table，做一个映射关系。所以路由器使用NAT功能和不使用的时候数据包中的源IP地址是有不同的，一个是永远不变，NAT功能的话转发时源IP地址改为自己的公网IP。以上仅为个人认知，仅供参考，若存在纰漏，欢迎指出，因为网络这块内容不是三言两语能解释完的，但是大致的思路就是这样子。推荐几篇文章加深理解：阮一峰的网络协议入门（一）阮一峰的网络协议入门（二）关于NAT理解关于ARP协议的知乎讨论内网和外网之间的通信MAC地址表、ARP缓存表以及路由表","link":"/2016/12/24/%E7%BD%91%E7%BB%9C%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BF%9E%E6%8E%A5/"},{"title":"装饰器模式(转)","text":"动态的给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更为灵活【GOF95】装饰模式是以对客户透明的方式动态地给一个对象附加上更多的职责。这也就是说，客户端并不会觉得对象在装饰前和装饰后有什么不同。装饰模式可以在不使用创造更多子类的情况下，将对象的功能加以扩展。 【装饰模式结构图】 【装饰模式中主要角色】抽象构件(Component)角色：定义一个对象接口，以规范准备接收附加职责的对象，从而可以给这些对象动态地添加职责。具体构件(Concrete Component)角色：定义一个将要接收附加职责的类。装饰(Decorator)角色：持有一个指向Component对象的指针，并定义一个与Component接口一致的接口。具体装饰(Concrete Decorator)角色：负责给构件对象增加附加的职责。【装饰模式的优缺点】装饰模式的优点:1、比静态继承更灵活；2、避免在层次结构高层的类有太多的特征装饰模式的缺点：1、使用装饰模式会产生比使用继承关系更多的对象。并且这些对象看上去都很想像，从而使得查错变得困难。【装饰模式适用场景】1、在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。2、处理那些可以撤消的职责，即需要动态的给一个对象添加功能并且这些功能是可以动态的撤消的。3、当不能彩生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。【装饰模式PHP示例】 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110&lt;?php/** * 装饰模式 2010-06-03 sz * @author phppan.p#gmail.com * http://www.phppan.com 哥学社成员（http://www.blog-brother.com/） * @package design pattern */ /** * 抽象构件角色 */interface Component { /** * 示例方法 */ public function operation();} /** * 装饰角色 */abstract class Decorator implements Component{ protected $_component; public function __construct(Component $component) { $this-&gt;_component = $component; } public function operation() { $this-&gt;_component-&gt;operation(); }} /** * 具体装饰类A */class ConcreteDecoratorA extends Decorator { public function __construct(Component $component) { parent::__construct($component); } public function operation() { parent::operation(); // 调用装饰类的操作 $this-&gt;addedOperationA(); // 新增加的操作 } /** * 新增加的操作A，即装饰上的功能 */ public function addedOperationA() { echo 'Add Operation A &lt;br /&gt;'; }} /** * 具体装饰类B */class ConcreteDecoratorB extends Decorator { public function __construct(Component $component) { parent::__construct($component); } public function operation() { parent::operation(); $this-&gt;addedOperationB(); } /** * 新增加的操作B，即装饰上的功能 */ public function addedOperationB() { echo 'Add Operation B &lt;br /&gt;'; }} /** * 具体构件 */class ConcreteComponent implements Component{ public function operation() { echo 'Concrete Component operation &lt;br /&gt;'; } } /** * 客户端 */class Client { /** * Main program. */ public static function main() { $component = new ConcreteComponent(); $decoratorA = new ConcreteDecoratorA($component); $decoratorB = new ConcreteDecoratorB($decoratorA); $decoratorA-&gt;operation(); $decoratorB-&gt;operation(); } } Client::main();?&gt; 从以上示例可以看出：1、装饰类中有一个属性$_component，其数据类型是Component;2、装饰类实现了Component接口;3、接口的实现是委派给父类，但并不是单纯的委派，还有功能的增强;4、具体装饰类实现了抽象装饰类的operation方法。本文转自：http://www.phppan.com/2010/06/php-design-pattern-4-decorator/","link":"/2017/03/12/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"title":"读书笔记-《解忧杂货铺》","text":"床柜上放着好几本家里带来的小说，总是觉得自己一直对文学作品没什么特别大的兴趣，主要是心静不下来看这些类型的书籍，平常买的技术书籍也是堆积在那里。但是近些日子觉得还是得多看一些书，出于对自己知识面的扩展，做技术日子久了，总感觉自己的知识面太过于狭窄。做技术（敲代码 的），闲暇时间本来就不多，就算有也是把一大半时间花在了技术知识的拓展上。时间总是有的，其实前几个月自己也是荒废了比较多的时间，如果把那些看似闲暇的时间花在读书上其实收益会挺大的。所以近段时间我会劲量多读些书，书籍的范围不限，可以看点小说也可以看一些聊技术的书。读书笔记写的东西很随意，只是写一些书的主要内容和感想，以便于日后想不起来还可以看一下自己的笔记。 书简介《解忧杂货铺》还是一本很畅销的书，好像是15年的书，占据各大排行榜最畅销书首位。前段日子，朋友还说这本书很好看 ，我就先开始读了这本。 内容回顾：一开始讲的就是三个小偷，这三个人分别叫做：翔太，敦也，幸平。他们在某个小区偷了东西，然后落荒而逃，逃到了一家店，也就是我们的书名所说的“解忧杂货铺”，故事就这么开始了。 这家店弥漫着一股奇怪的气息，他们从屋里的听到砰的响声，是屋外的牛奶箱里掉落的一封信。故事就是围绕这个接受信的牛奶箱和另外一个投递信件的窗口展开的。他们收到了一封来自过去的信，写信的人是一个叫做月兔的人，时间点大概在1979年。月兔是一名击剑运动员，他从朋友那里听说，这里有一家可以帮人解除烦恼的店，也就是这家“浪矢杂货铺”，她的烦恼是她有一个卧病在床的男友，他们都是运动员，月兔想放弃奥运会去照看男友，而男友的愿望就是月兔能够进入奥运会，这是即将死去的他唯一的愿望，月兔不知道怎么办，爱和理想产生了冲突。这三个人随即回了信，刚开始他们还不知道月兔的信是来自过去，但一来二去他们就开始明白，原来他们正在和过去的人进行对话，这家杂货铺的信箱连接着过去和未来。就这样，书分5个章节写了5个故事，第一个讲的理想和爱情产生冲突的奥运选手，第二章讲的是为了音乐奋斗而不知道自己能否坚持下去的克朗，前两章的信都是寄到了未来，这三个人和过去的有烦恼的人提供了建议，第三章写的解忧杂货铺的主人浪失雄治，这里很关键，说的是杂货铺的由来，以及之所以杂货铺连接着过去和未来的原因，是店主雄治在死前的一个心愿就是在自己33年后的忌日能够知道他帮过去解决烦恼的人现在怎么样了（因为他经常做到一个梦），他的建议是不是起到了帮助，在死之前，他把这个心愿托福给了自己的儿子贵之，贵之也按照他的要求去做了，然后在他们最后一次从城里贵之的家回到关闭的杂货铺收到很多来自未来的信，他们竟然成功地连接了未来，雄治做的梦是对的。最后两章也是讲的类似的故事，就是遇到烦恼了，去到杂货铺解决了，不过所反映的确实他们各自的人生，一个是富有家庭的孩子，父母生意失败了，举家逃难，这个人对人生充满了怀疑，他那时的心境就是觉得父母自私，没有为他考虑，当他像浪矢爷爷求助时，尽管浪矢建议他应该和父母在一起，但他还是在逃亡的过程中离开了他的父母，他一直觉得当初没有听浪矢的话是对的，他与父母断了联系，以一个姓的名字藤川博过着新的生活，知道他从网上知道浪矢杂货铺咨询烦恼窗口在32年后重新启动了，目的是想知道那些过去浪矢爷爷咨询烦恼的人现在怎么样了。这家伙自鸣得意，觉得自己过得很好，想证明自己当初没听浪矢的建议是很对的，就写了封回信准备送过去，直到他在送信的路上才知道了真相，在他和父母分离，他的父母也随即自杀了，原因是父母活下去的唯一希望是他们的儿子。而父母自杀的方式也很诡异，父亲写了一封自杀的信，信上说自杀的是一家三口，逆海身亡。之所以这么做，只有死于海中，尸体很难打捞，找不到很正常，他们知道自己的孩子还活着，不希望死了还影响到自己的孩子，就选择死于海中，希望自己的孩子能够以新的生活开始。（我说的有些蹩脚，但情节还是很感人的）这个故事的剧情大概就是这个样子。最后一章节，讲的就是过去和未来打通的故事。讲了一个陪酒的女生，在这三个人的帮助下，放弃了配酒的工作，开始听从来自未来的三个人建议（你懂得 建议就是让她搞房地产，股票，以及什么时间点去做哪些事情），在他们的帮助下，在他们的帮助下，这个叫静美的女人从此过上了幸福的生活，最终在时间点上未来和过去产生了联系，静美来到了50多岁，和这个时空的这三个人发生了联系。联系就是开头的这三个小偷落荒而逃的原因，他们偷了一家的东西，这家的主人就是静美，并且绑架了那个想在杂货铺重开的那段时间写感谢信给浪矢的静美（静美不知道提供给他建议的是这个三个人）。 感想内容写的有点多，小说的故事线还是很丰富的。这么点文字只能写出个大概。小说里的每个故事很形象的展示出了那些遇到困难人的心境。每个小故事都能透露着普通人的人性。他们的有一些想法我也有过。整体上这本书还是可以的，故事串联的很好，每个故事都存在这关联，连接方式就是丸光圆和杂货铺。","link":"/2017/11/04/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E3%80%8A%E8%A7%A3%E5%BF%A7%E6%9D%82%E8%B4%A7%E9%93%BA%E3%80%8B/"},{"title":"适配器模式","text":"读了《设计模式之蝉》之适配器模式后的总结。 C适配器模式的定义：onvert the interface of a class into another interface clients expect.Adapter lets classes work togeher that couldn’t otherwise because of incompatible interfaces.(将一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无发在一起工作的两个类能够在一起工作) 类适配器原有公司的内部员工形象有这么一个接口（target） 1234567891011121314151617181920212223242526272829303132333435363738&lt;?php interface IuserInfo{ public function getUserName(); public function getHomeAdress(); public function getMobileNumber(); public function getOfficeTelNumber(); public function getJobPosition(); public function getHomeNumber(); }public class UserInfo implements IuserInfo{ public function getUserName(){ echo \"名字是....\" }; public function getHomeAdress(){ echo \"家庭住址是....\" }; public function getMobileNumber(){ echo \"手机号码是....\" }; public function getOfficeTelNumber(){ echo \"办公室号码是...\" }; public function getHomeNumber(){ echo \"家里的号码是...\" }; public function getJobPosition(){ echo \"办公室位置式...\" };}public class clients{ public main function(){ $user = new UserInfo(); $user-&gt;getUserName(); }} 一切看上去都没有什么问题，但是可能处于某种原因，公司需要从其他公司租用的员工的信息。而其他公司租用的员工信息的接口是这个样子的。 123456789101112131415161718192021&lt;?php interface IouterUserInfo(){ public function userNumber(); public function userAddress(); } public class OuterUser implements IouterUserInfo{ public function userNumber(){ $telnumber = ['moblie_number' =&gt; '135...', 'office_mobile_number' =&gt;'001-12..', 'home_tel_number' =&gt; '002-22' ]; return $telnumber; } public function baseInfo(){ $info = ['name' =&gt; 'steve', 'office_address' =&gt; '办公室位置...', 'home_address' =&gt; '家的位置是...' ]; return $info; } } 这和我们原先的接口完全不同，我们希望还是希望以自己接口设计去获取信息，因为这样就不需要大修改原先已经写好的客户端类。我们这里就可以用到适配器模式。 123456789101112131415161718192021222324&lt;?php //类适配器 OuterUserInfo public class OuterUserInfo extends OuterUser implements UserInfo{ public function getUserName(){ echo $this-&gt;baseInfo()['name']; }; public function getHomeAdress(){ }; public function getMobileNumber(){ }; public function getOfficeTelNumber(){ }; public function getHomeNumber(){ }; public function getJobPosition(){ }; } //客户端相对于之前只是改了实例其他不变。 public class clients{ public main function(){ $user = new OuterUserInfo(); $user-&gt;getUserName(); }} 对象适配器如果是多个不同的接口则可以用对象适配器对象适配器和类适配器的不同就是，对象适配器是把对象注入到适配器内部而不是通过继承直接使用。假如我们把IouterUserInfo一分为二，mobile归IouterUserMobile（通讯录），IouterUserInfo接口则是基本信息（姓名和地址）。那么类适配器是不能继承两个类的，所以采用对象适配器来解决。 123456789&lt;?php public class OuterUserInfo implements UserInfo{ private $outerUserMobile; private $outerUserInfo; public function __construct(OuterUserInfo $outrUserInfo,OuterUserMoblie $outerUserMobile) { $this-&gt;outerUserMobile = $outerUserMobile; $this-&gt;outerUserInfo = $outerUserInfo; } }","link":"/2017/01/18/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"title":"重新构建二叉树","text":"输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 123456789101112131415161718192021222324252627282930313233343536class Solution {public: TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) { //判断两个向量大小是否相等 if(preorder.size() != inorder.size()) return NULL; int length = preorder.size(); //传入首尾的索引 return constructTree(preorder,0,length-1,inorder,0,length-1); } TreeNode* constructTree(vector&lt;int&gt;&amp; preorder,int ps, int pend,vector&lt;int&gt;&amp; inorder ,int is,int iend){ //边界值判断 超出就表示没有左右树了。 if(ps&gt;pend || is&gt;iend) return NULL; TreeNode *root = new TreeNode(preorder[ps]); int irootpos; for(int i=is;i&lt;=iend;i++){ if(inorder[i] == root-&gt;val){ irootpos = i; break; } } //获取中序的左边的长度 表示左子树的大小 int leftlength = irootpos - is; //获取中序的右边的长度 表示右子树的大小 int rightlength = iend - irootpos; //进入递归 root-&gt;left = constructTree(preorder,ps+1,ps+leftlength,inorder,is,irootpos-1); root-&gt;right = constructTree(preorder,pend-rightlength+1,pend,inorder,irootpos+1,iend); //返回根节点 return root; } };","link":"/2017/01/25/%E9%87%8D%E6%96%B0%E6%9E%84%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"title":"高性能MySQL之索引（一）","text":"这篇文章来自于对《高性能MySQL》的总结 索引（在mysql中叫做“key”）是存储引擎用于快速找到记录的一种数据结构。 索引基础就像看书一样，我们想要找我们想看的内容都会翻到书的目录，找到对应的章节。这里的目录就是现实生活中的索引。在mysql中，在存储引擎用类似的方式使用索引，其先在索引中找到对应值，然后根据匹配的索引记录找到对应的数据行。 索引的类型Mysql索引的类型有B-Tree索引，哈希索引，空间数据索引（R-Tree），全文索引。 Btree索引 当人们谈论索引的时候，如果没有特别指明类型，多半说的就是B-Tree数据结构来存储数据。大多数Mysql引擎都支持这种索引.Archive引擎是一个例外：5.1之前Archive不支持任何索引，直到5.1才开始支持单个自增列（AUTO_INCREMENT）的索引。我们使用的术语“B-Tree”,是因为在MySQL在Create Table和其他语句中也使用该关键字。不过底层的存储引擎也可能使用不同的存储结构，例如NDB集群存储引擎内部实际上使用了T-Tree结构存储这种引擎，即使其名字是BTREE；Innodb则使用B+Tree，各种数据结构和算法的变种不在本讨论范围之内。 ![B-Tree结构][1]建立在B-Tree树上的索引（技术上是B+Tree）B-Tree索引能够加快访问数据的速度，因为存储引擎不再需要进行全表扫描来获取需要的数据，取而代之的是从索引的根节点（图示并未画出）开始进行搜索。根节点槽中存放了指向子节点的指针，存储引擎根据这些指向下层查找。通过比较节点页的值和要查找的值可以找到合适的指针进入下层子节点，这些指针实际上定义了子节点页中值的上限和下限。最终存储引擎要么是找到对应的值，要么该记录不存在。叶子节点页比较特别，它们的指针指向的是被索引的数据，而不是其他的节点页。 [1]: http://wx2.sinaimg.cn/mw690/7503dc51gy1fcoo7uy3rnj20rh0c7ab2.jpg 索引有效查询方式全值匹配全值匹配指的是和索引中的所有列进行匹配，例如前面提到的索引可用于查找姓名为Cuba Allen，出生于1960-01-01的人。 匹配最左前缀前面提到的索引可用于查找所有姓为Allen的人，即只使用索引的第一列。 匹配范围值例如前面提到的索引可以用于查找姓在Allen和Barrymore之间的人。这里只使用了索引的第一列。 精确匹配某一列并范围匹配另外一列前面提到的索引也可用于查找所有姓为Allen，并且名字是字母K开头（比如Kim,Karl等）的人。即第一列last_name全匹配，第二列first_name范围匹配。 只访问索引的查询B-Tree通常可以支持“只访问索引的查询”，即查询只需要访问索引，而无需访问数据行。这种方式叫做“覆盖索引”。 索引的限制 如果不是按照索引的最左列开始查询，则无法使用索引。 不能跳过索引中的列。 如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找。 总结：索引列的顺序是很重要的，这些限制都和索引列的顺序有关。在优化性能的时候，可能需要使用相同的列但顺序不同的索引来满足不同类型的查询需求。","link":"/2017/02/13/%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E4%B9%8B%E7%B4%A2%E5%BC%95%EF%BC%88%E4%B8%80%EF%BC%89/"},{"title":"Csrf初识（转）","text":"浅谈CSRF攻击方式一.CSRF是什么？ CSRF（Cross-site request forgery），中文名称：跨站请求伪造，也被称为：one click attack/session riding，缩写为：CSRF/XSRF。 二.CSRF可以做什么？ 你这可以这么理解CSRF攻击：攻击者盗用了你的身份，以你的名义发送恶意请求。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账……造成的问题包括：个人隐私泄露以及财产安全。 三.CSRF漏洞现状 CSRF这种攻击方式在2000年已经被国外的安全人员提出，但在国内，直到06年才开始被关注，08年，国内外的多个大型社区和交互网站分别爆出CSRF漏洞，如：NYTimes.com（纽约时报）、Metafilter（一个大型的BLOG网站），YouTube和百度HI……而现在，互联网上的许多站点仍对此毫无防备，以至于安全业界称CSRF为“沉睡的巨人”。 ###四.CSRF的原理 下图简单阐述了CSRF攻击的思想： 从上图可以看出，要完成一次CSRF攻击，受害者必须依次完成两个步骤： 1.登录受信任网站A，并在本地生成Cookie。 2.在不登出A的情况下，访问危险网站B。 看到这里，你也许会说：“如果我不满足以上两个条件中的一个，我就不会受到CSRF的攻击”。是的，确实如此，但你不能保证以下情况不会发生： 1.你不能保证你登录了一个网站后，不再打开一个tab页面并访问另外的网站。 2.你不能保证你关闭浏览器了后，你本地的Cookie立刻过期，你上次的会话已经结束。（事实上，关闭浏览器不能结束一个会话，但大多数人都会错误的认为关闭浏览器就等于退出登录/结束会话了……） 3.上图中所谓的攻击网站，可能是一个存在其他漏洞的可信任的经常被人访问的网站。 上面大概地讲了一下CSRF攻击的思想，下面我将用几个例子详细说说具体的CSRF攻击，这里我以一个银行转账的操作作为例子（仅仅是例子，真实的银行网站没这么傻:&gt;） 示例1： 银行网站A，它以GET请求来完成银行转账的操作，如：http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000 危险网站B，它里面有一段HTML的代码如下： 1&lt;img src=http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000&gt; 首先，你登录了银行网站A，然后访问危险网站B，噢，这时你会发现你的银行账户少了1000块…… 为什么会这样呢？原因是银行网站A违反了HTTP规范，使用GET请求更新资源。在访问危险网站B的之前，你已经登录了银行网站A，而B中的以GET的方式请求第三方资源（这里的第三方就是指银行网站了，原本这是一个合法的请求，但这里被不法分子利用了），所以你的浏览器会带上你的银行网站A的Cookie发出Get请求，去获取资源“http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000”，结果银行网站服务器收到请求后，认为这是一个更新资源操作（转账操作），所以就立刻进行转账操作…… 示例2： 为了杜绝上面的问题，银行决定改用POST请求完成转账操作。 银行网站A的WEB表单如下： 12345&lt;form action=\"Transfer.php\" method=\"POST\"&gt; &lt;p&gt;ToBankId: &lt;input type=\"text\" name=\"toBankId\" /&gt;&lt;/p&gt; &lt;p&gt;Money: &lt;input type=\"text\" name=\"money\" /&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"submit\" value=\"Transfer\" /&gt;&lt;/p&gt; &lt;/form&gt; 后台处理页面Transfer.php如下： 1234567 &lt;?php session_start(); if (isset($_REQUEST['toBankId'] &amp;&amp; isset($_REQUEST['money'])) { buy_stocks($_REQUEST['toBankId'], $_REQUEST['money']); } ?&gt; 危险网站B，仍然只是包含那句HTML代码： 1 &lt;img src=http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000&gt; 和示例1中的操作一样，你首先登录了银行网站A，然后访问危险网站B，结果…..和示例1一样，你再次没了1000块～T_T，这次事故的原因是：银行后台使用了$_REQUEST去获取请求的数据，而$_REQUEST既可以获取GET请求的数据，也可以获取POST请求的数据，这就造成了在后台处理程序无法区分这到底是GET请求的数据还是POST请求的数据。在PHP中，可以使用$_GET和$_POST分别获取GET请求和POST请求的数据。在JAVA中，用于获取请求数据request一样存在不能区分GET请求数据和POST数据的问题。 示例3： 经过前面2个惨痛的教训，银行决定把获取请求数据的方法也改了，改用$_POST，只获取POST请求的数据，后台处理页面Transfer.php代码如下： 1234567 &lt;?php session_start(); if (isset($_POST['toBankId'] &amp;&amp; isset($_POST['money'])) { buy_stocks($_POST['toBankId'], $_POST['money']); } ?&gt; 然而，危险网站B与时俱进，它改了一下代码： 1234567891011121314151617181920&lt;html&gt; &lt;head&gt; &lt;script type=\"text/javascript\"&gt; function steal() { iframe = document.frames[\"steal\"]; iframe.document.Submit(\"transfer\"); } &lt;/script&gt; &lt;/head&gt; &lt;body onload=\"steal()\"&gt; &lt;iframe name=\"steal\" display=\"none\"&gt; &lt;form method=\"POST\" name=\"transfer\" action=\"http://www.myBank.com/Transfer.php\"&gt; &lt;input type=\"hidden\" name=\"toBankId\" value=\"11\"&gt; &lt;input type=\"hidden\" name=\"money\" value=\"1000\"&gt; &lt;/form&gt; &lt;/iframe&gt; &lt;/body&gt;&lt;/html&gt; 如果用户仍是继续上面的操作，很不幸，结果将会是再次不见1000块……因为这里危险网站B暗地里发送了POST请求到银行! 总结一下上面3个例子，CSRF主要的攻击模式基本上是以上的3种，其中以第1,2种最为严重，因为触发条件很简单，一个就可以了，而第3种比较麻烦，需要使用JavaScript，所以使用的机会会比前面的少很多，但无论是哪种情况，只要触发了CSRF攻击，后果都有可能很严重。 理解上面的3种攻击模式，其实可以看出，CSRF攻击是源于WEB的隐式身份验证机制！WEB的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的！ ###五.CSRF的防御 我总结了一下看到的资料，CSRF的防御可以从服务端和客户端两方面着手，防御效果是从服务端着手效果比较好，现在一般的CSRF防御也都在服务端进行。 1.服务端进行CSRF防御 服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数。 (1).Cookie Hashing(所有表单都包含同一个伪随机值)： 这可能是最简单的解决方案了，因为攻击者不能获得第三方的Cookie(理论上)，所以表单中的数据也就构造失败了:&gt; 12345 &lt;?php //构造加密的Cookie信息 $value = “DefenseSCRF”; setcookie(”cookie”, $value, time()+3600); ?&gt; 在表单里增加Hash值，以认证这确实是用户发送的请求。 123456789 &lt;?php $hash = md5($_COOKIE['cookie']); ?&gt; &lt;form method=”POST” action=”transfer.php”&gt; &lt;input type=”text” name=”toBankId”&gt; &lt;input type=”text” name=”money”&gt; &lt;input type=”hidden” name=”hash” value=”&lt;?=$hash;?&gt;”&gt; &lt;input type=”submit” name=”submit” value=”Submit”&gt; &lt;/form&gt; 然后在服务器端进行Hash值验证 123456789101112&lt;?php if(isset($_POST['check'])) { $hash = md5($_COOKIE['cookie']); if($_POST['check'] == $hash) { doJob(); } else { //... } } else { //... }?&gt; 这个方法个人觉得已经可以杜绝99%的CSRF攻击了，那还有1%呢….由于用户的Cookie很容易由于网站的XSS漏洞而被盗取，这就另外的1%。一般的攻击者看到有需要算Hash值，基本都会放弃了，某些除外，所以如果需要100%的杜绝，这个不是最好的方法。 (2).验证码 这个方案的思路是：每次的用户提交都需要用户在表单中填写一个图片上的随机字符串，厄….这个方案可以完全解决CSRF，但个人觉得在易用性方面似乎不是太好，还有听闻是验证码图片的使用涉及了一个被称为MHTML的Bug，可能在某些版本的微软IE中受影响。 (3).One-Time Tokens(不同的表单包含一个不同的伪随机值) 在实现One-Time Tokens时，需要注意一点：就是“并行会话的兼容”。如果用户在一个站点上同时打开了两个不同的表单，CSRF保护措施不应该影响到他对任何表单的提交。考虑一下如果每次表单被装入时站点生成一个伪随机值来覆盖以前的伪随机值将会发生什么情况：用户只能成功地提交他最后打开的表单，因为所有其他的表单都含有非法的伪随机值。必须小心操作以确保CSRF保护措施不会影响选项卡式的浏览或者利用多个浏览器窗口浏览一个站点。 以下我的实现: 1).先是令牌生成函数(gen_token())： 1234567&lt;?phpfunction gen_token() { //这里我是贪方便，实际上单使用Rand()得出的随机数作为令牌，也是不安全的。 //这个可以参考我写的Findbugs笔记中的《Random object created and used only once》 $token = md5(uniqid(rand(), true)); return $token;} 2).然后是Session令牌生成函数(gen_stoken())： 123456789101112&lt;?php function gen_stoken() { $pToken = \"\"; if($_SESSION[STOKEN_NAME] == $pToken){ //没有值，赋新值 $_SESSION[STOKEN_NAME] = gen_token(); } else{ //继续使用旧的值 } }?&gt; 3).WEB表单生成隐藏输入域的函数： 1234567&lt;?php function gen_input() { gen_stoken(); echo “&lt;input type=\\”hidden\\” name=\\”\" . FTOKEN_NAME . “\\” value=\\”\" . $_SESSION[STOKEN_NAME] . “\\”&gt; “; }?&gt; 4).WEB表单结构： 12345678910&lt;?php session_start(); include(”functions.php”);?&gt;&lt;form method=”POST” action=”transfer.php”&gt; &lt;input type=”text” name=”toBankId”&gt; &lt;input type=”text” name=”money”&gt; &lt;? gen_input(); ?&gt; &lt;input type=”submit” name=”submit” value=”Submit”&gt;&lt;/FORM&gt; 5).服务端核对令牌： 这个很简单，这里就不再啰嗦了。 上面这个其实不完全符合“并行会话的兼容”的规则，大家可以在此基础上修改。 其实还有很多想写，无奈精力有限，暂且打住，日后补充，如果错漏，请指出:&gt; PS：今天下午写这篇文档的时候FF崩溃了一次，写了一半文章的全没了，郁闷好久T_T……. 转载请说明出处，谢谢[hyddd(http://www.cnblogs.com/hyddd/)]","link":"/2017/03/05/Csrf-learnning/"}],"tags":[{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"},{"name":"C&数据结构","slug":"C-数据结构","link":"/tags/C-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"协议","slug":"协议","link":"/tags/%E5%8D%8F%E8%AE%AE/"}],"categories":[{"name":"leetcode","slug":"leetcode","link":"/categories/leetcode/"},{"name":"C&数据结构","slug":"C-数据结构","link":"/categories/C-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"年度","slug":"年度","link":"/categories/%E5%B9%B4%E5%BA%A6/"},{"name":"设计模式","slug":"设计模式","link":"/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"PHP","slug":"PHP","link":"/categories/PHP/"},{"name":"协议","slug":"协议","link":"/categories/%E5%8D%8F%E8%AE%AE/"},{"name":"读书","slug":"读书","link":"/categories/%E8%AF%BB%E4%B9%A6/"},{"name":"TCP/IP","slug":"TCP-IP","link":"/categories/TCP-IP/"},{"name":"MySQL","slug":"MySQL","link":"/categories/MySQL/"},{"name":"Web","slug":"Web","link":"/categories/Web/"}]}